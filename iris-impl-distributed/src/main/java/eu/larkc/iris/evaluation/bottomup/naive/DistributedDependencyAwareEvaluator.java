/*
 * Copyright 2010 Softgress - http://www.softgress.com/
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package eu.larkc.iris.evaluation.bottomup.naive;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;

import org.deri.iris.EvaluationException;
import org.deri.iris.api.basics.ILiteral;
import org.deri.iris.api.basics.IPredicate;
import org.deri.iris.api.basics.IRule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import eu.larkc.iris.evaluation.EvaluationContext;
import eu.larkc.iris.evaluation.bottomup.IDistributedRuleEvaluator;
import eu.larkc.iris.evaluation.bottomup.IRuleEvaluationBlocker;
import eu.larkc.iris.rules.compiler.IDistributedCompiledRule;

/**
 * Defines the evaluator used for the rules on one stratum.
 * If some data is generated by the evaluation of any of the rules then all the rules are evaluated again until no more data is produced.
 * 
 * 
 * @author florian.fischer@softgress.com
 */
public class DistributedDependencyAwareEvaluator implements IDistributedRuleEvaluator {

	private static final Logger logger = LoggerFactory.getLogger(DistributedDependencyAwareEvaluator.class);
	
	@Override
	public void evaluateRules(Integer stratumNumber, List<IDistributedCompiledRule> rules, eu.larkc.iris.Configuration configuration) throws EvaluationException {
		String methodName = "evaluateRules(Integer, List<IDistributedCompiledRule, Configuration)";
		
		if(logger.isInfoEnabled()) {
			StringBuilder log = new StringBuilder();
			log.append("Method: " + methodName + "\n");
			log.append("Stratum: " + stratumNumber + "\n");
			log.append("Rules: ");
			for (IDistributedCompiledRule rule : rules) {
				log.append("\n" + rule.getRule());
			}
			
			logger.info(log.toString());
		}
		
		//clear objects after each evaluation
		dynamicDependencyMap.clear();
		predicatesToEvaluate.clear();
		contextMap.clear();
			
		//optionally: completely block some rules from re-evaluation
		blockers = configuration.ruleEvaluationBlockers;
		
		//transform flat list to hashmap reflecting the dependencies between rules (more particularly predicates)
		transformToDependencyMap(rules);
		
		//init all rules		
		initEvaluationContext(rules, stratumNumber);
		
		//one initial round of evaluation over all rules
		internalEvaluate(rules);
	
		//initially those will be the head predicates
		while( !predicatesToEvaluate.isEmpty()) {
			//remove predicate from top of queue
			IPredicate toEvaluate = predicatesToEvaluate.poll();
			
			//get rules that depend on this predicate (i.e. it is a body predicate of them)
			List<IDistributedCompiledRule> dependingRules = dynamicDependencyMap.get(toEvaluate);
	
			if(logger.isInfoEnabled()) {
				logger.info("Depending rules: " + dependingRules);
				logger.info("Depending on predicate: " + toEvaluate);
			}			
			
			//process all depending rules
			if(dependingRules != null && !dependingRules.isEmpty())	{
				internalEvaluate(dependingRules);					
			}			
		}
		
		if(logger.isInfoEnabled()) {
			StringBuilder log = new StringBuilder();
			log.append("Method: " + methodName + "\n");
			log.append("Done with Stratum: " + stratumNumber + "\n");
			
			logger.info(log.toString());
		}
	}
	
	/**
	 * Internal evaluation method.
	 * 
	 * @param toEvaluate
	 * @throws EvaluationException 
	 */
	private void internalEvaluate(List<IDistributedCompiledRule> toEvaluate) throws EvaluationException {		
		String methodName = "internalEvaluate(List<IDistributedCompiledRule)";
		
		if(logger.isInfoEnabled()) {
			StringBuilder log = new StringBuilder();
			log.append("Method: " + methodName + "\n");
			log.append("Rules:");
			for (IDistributedCompiledRule rule : toEvaluate) {
				log.append("\n" + rule.toString());
			}
			
			logger.info(log.toString());
		}
		
		
		for (IDistributedCompiledRule currentRule: toEvaluate) {
			
			//get evaluation context and increment iteration number after evaluation of this rule
			EvaluationContext ctx = contextMap.get(currentRule);			
			if(logger.isInfoEnabled()) {
				logger.info("Evaluating rule: " + currentRule);
				logger.info("EvaluationContext: " + ctx);
			}	
			
			boolean delta = currentRule.evaluate(ctx);
			ctx.setIterationNumber(ctx.getIterationNumber() + 1);
			
			//new data was derived, take head predicate and push it on the "update queue"
			if(delta && !isBlocked(currentRule.getRule())) {
				IPredicate headPredicate = currentRule.getRule().getHead().get(0).getAtom().getPredicate();
				
				//add for re-computation (if not already present)
				insertForFutureEvaluation(headPredicate);
			}
			
		}
	}
	
	/**
	 * Initializes an evaluation context for each rule
	 * 
	 * @param rules
	 * @param stratumNumber
	 */
	private void initEvaluationContext(List<IDistributedCompiledRule> rules, Integer stratumNumber) {
		int ruleNumber = 1;
		int iterationNumber = 1;
		for(IDistributedCompiledRule rule : rules) {
			contextMap.put(rule, new EvaluationContext(stratumNumber, iterationNumber, ruleNumber));
			ruleNumber++; //we simply enumerate all rules. in combination with stratum and iteration number this gives a unique identifier
		}		
	}
	
	
	/**
	 * This method transforms the flat last of rules into a HashMap that reflects the dependency of rules on its body predicates.
	 * This allows to get all rules that need to be recomputed when a specific predicate is updated.
	 * 
	 * @param rules
	 */
	private void transformToDependencyMap(List<IDistributedCompiledRule> rules) {
		
		for (IDistributedCompiledRule currentRule : rules) {			
			//for each body predicate we keep track of the rules that it occurs in.
			//each time when the body predicate is updated from some other location
			//we can look up rules depending on it and re-evaluate those.
			List<ILiteral> bodyLiterals = currentRule.getRule().getBody();
			for (ILiteral bodyLit : bodyLiterals) {
				IPredicate bodyPredicate = bodyLit.getAtom().getPredicate();
				insertOrUpdateDependency(bodyPredicate, currentRule);
			}
		}
	}
	
	/**
	 * Inserts a predicate for future evaluation. If the predicate is already scheduled this returns false.
	 * 
	 * @param predicate
	 * @return True if the predicate was inserted for re-computation. False if the predicate was already scheduled.
	 */
	private boolean insertForFutureEvaluation(IPredicate predicate) {
		String methodName = "insertForFutureEvaluation(IPredicate)";
		
		if(predicatesToEvaluate.contains(predicate)) {
			return false;
		} else {
			if(logger.isInfoEnabled()) {
				StringBuilder log = new StringBuilder();
				log.append("Method: " + methodName + "\n");
				log.append("IPredicate: " + predicate);
				logger.info(log.toString());
			}			
			return predicatesToEvaluate.add(predicate);
		}
	}
	
	/** 
	 * @param p
	 * @param rule
	 */
	private void insertOrUpdateDependency(IPredicate p, IDistributedCompiledRule rule) {
		String methodName = "insertOrUpdateDependency(IPredicate, IDistributedCompiledRule)";
		
		if( !dynamicDependencyMap.containsKey(p)) {
			List<IDistributedCompiledRule> rules = new ArrayList<IDistributedCompiledRule>();			
			dynamicDependencyMap.put(p, rules);
		}
		
		if(logger.isInfoEnabled()) {
			StringBuilder log = new StringBuilder();
			log.append("Method: " + methodName + "\n");
			log.append("IPredicate: " + p + "\n");
			log.append("IDistributedCompiledRule: " + rule);
			logger.info(log.toString());
		}	
		dynamicDependencyMap.get(p).add(rule);
	}
	
	/**
	 * Checks if a rule should not be re-evaluated at all.
	 * 
	 * @param rule
	 * @return
	 */
	private boolean isBlocked(IRule rule) {
		
		for (IRuleEvaluationBlocker blocker : blockers) {
			if(blocker.block(rule)) {
				if(logger.isInfoEnabled()) {
					logger.info("Rule blocked: " + rule);
				}
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Keeps track of predicates and rules that need to be re-evaluated when the predicate is updated in some way
	 */
	private Map<IPredicate, List<IDistributedCompiledRule>> dynamicDependencyMap = new HashMap<IPredicate, List<IDistributedCompiledRule>>(); 
	
	/**
	 * Allows to block rules for performance reasons.
	 */
	private List<IRuleEvaluationBlocker> blockers;
	
	/**
	 * Queued up set of predicates that have been updated and determine rules to be re-evaluated.
	 */
	private Queue<IPredicate> predicatesToEvaluate = new LinkedList<IPredicate>();
	
	/**
	 * Map to keep track and update the evaluation context of a rule.
	 */
	Map<IDistributedCompiledRule, EvaluationContext> contextMap = new HashMap<IDistributedCompiledRule, EvaluationContext>();
}
